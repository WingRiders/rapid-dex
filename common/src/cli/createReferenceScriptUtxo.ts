import {
  type NetworkId,
  type SupportedNetwork,
  walletNetworkIdToNetwork,
} from '@/helpers/wallet'
import {poolValidatorCompiledCode, poolValidatorHash} from '@/onChain'
import {Serialization} from '@cardano-sdk/core'
import {
  BlockfrostProvider,
  MeshTxBuilder,
  MeshWallet,
  type Network,
  applyCborEncoding,
  serializePlutusScript,
} from '@meshsdk/core'
import {LOVELACE_UNIT} from '../helpers'

const DEFAULT_REF_SCRIPT_HOLDER_ADDRESS: Record<SupportedNetwork, string> = {
  preprod:
    'addr_test1qqlfh42dn2ndvpxcrrc6nt7u36ctz3krwwvpu65rl6zyaqwnt0wn7dhjucum8cuh0v7gcyuwpj0e56pxff74mefcyzrqe72pne',
}

// Wrap to a CBOR array together with script version
const scriptCborToScriptRef = (scriptCbor: string) => `8203${scriptCbor}`

// The content doesn't need to be formatted, biome will be run on the file
// Provide full UTxO so it does not have to be fetched on every building of a transaction
const createResultFileContent = (
  network: Network,
  txHash: string,
  lovelaceOnRefScriptUtxo: string,
  refScriptHolderAddress: string,
  scriptCbor: string,
  scriptHash: string,
  scriptAddr: string,
  scriptSize: number,
): string =>
  [
    '// IMPORTANT: This file is automatically generated by createReferenceScriptUtxo script, do not edit it manually',
    "import type {UTxO} from '@meshsdk/core'",
    '',
    `export const ${network}PoolRefScriptUtxo: UTxO = {`,
    `  input: {txHash: '${txHash}', outputIndex: 0},`,
    `  output: {address: '${refScriptHolderAddress}', amount: [{unit: '${LOVELACE_UNIT}', quantity: '${lovelaceOnRefScriptUtxo}'}], scriptRef: '${scriptCborToScriptRef(scriptCbor)}', scriptHash: '${scriptHash}'},`,
    '}',
    '',
    `export const ${network}PoolRefScriptSize = ${scriptSize}`,
    '',
    `export const ${network}PoolScriptAddress = '${scriptAddr}'`,
  ].join('\n')

type CreateReferenceScriptUtxoParams = {
  blockfrostProjectId: string
  networkId: NetworkId
  mnemonic: string
  stakeKeyHash: string
  refScriptHolderAddress?: string
}

export const createReferenceScriptUtxo = async ({
  blockfrostProjectId,
  networkId,
  mnemonic,
  stakeKeyHash,
  refScriptHolderAddress: refScriptHolderAddressParam,
}: CreateReferenceScriptUtxoParams) => {
  const blockchainProvider = new BlockfrostProvider(blockfrostProjectId)
  console.info('Init wallet')
  const wallet = new MeshWallet({
    networkId,
    fetcher: blockchainProvider,
    submitter: blockchainProvider,
    key: {
      type: 'mnemonic',
      words: mnemonic.split(' '),
    },
  })

  console.info('Fetching addresses')
  await wallet.init()
  const changeAddress = await wallet.getChangeAddress()

  console.info('Fetching UTxOs')
  const utxos = await wallet.getUtxos()
  if (utxos.length === 0) {
    console.error('Found no UTxOs, exiting')
    process.exit(1)
  }
  console.info(`Found ${utxos.length} UTxOs`)

  const network = walletNetworkIdToNetwork(networkId)
  const refScriptHolderAddress =
    refScriptHolderAddressParam || DEFAULT_REF_SCRIPT_HOLDER_ADDRESS[network]
  console.info(`Building transaction with output on ${refScriptHolderAddress}`)
  const scriptCbor = applyCborEncoding(poolValidatorCompiledCode)
  const txBuilder = new MeshTxBuilder({
    fetcher: blockchainProvider,
    verbose: false,
  })

  const unsignedTx = await txBuilder
    .setNetwork(network)
    .txOut(refScriptHolderAddress, [])
    .txOutReferenceScript(scriptCbor, 'V3')
    .changeAddress(changeAddress)
    .selectUtxosFrom(utxos)
    .complete()

  const lovelaceOnRefScriptUtxo = Serialization.Transaction.fromCbor(
    Serialization.TxCBOR(unsignedTx),
  )
    .body()
    .outputs()[0]!
    .amount()
    .coin()
    .toString()
  console.info(
    `Reference script is on UTxO with ${lovelaceOnRefScriptUtxo} lovelace`,
  )

  console.info('Signing transaction')
  const signedTx = await wallet.signTx(unsignedTx)
  console.info({txSize: signedTx.length / 2}, 'Submitting transaction')
  let txHash: string | null = null
  try {
    txHash = await wallet.submitTx(signedTx)
    console.info('Transaction submitted with hash:', txHash)
  } catch (e: unknown) {
    console.info({signedTx}, 'Error when submitting transaction')
    console.error(e instanceof Error ? e.message : JSON.stringify(e))
    process.exit(1)
  }

  const scriptAddr = serializePlutusScript(
    {
      code: scriptCbor,
      version: 'V3',
    },
    stakeKeyHash,
    networkId,
  ).address
  console.info('Computed script address:', scriptAddr)

  const file = `src/refScriptUtxos/${network}.ts`
  console.info(`Writing reference script UTxO to file ${file}`)
  const content = createResultFileContent(
    network,
    txHash,
    lovelaceOnRefScriptUtxo,
    refScriptHolderAddress,
    scriptCbor,
    poolValidatorHash,
    scriptAddr,
    scriptCbor.length / 2,
  )
  await Bun.write(file, content)

  // Run Biome to format the file
  console.info(`Running Biome on ${file}`)
  const exitCode = await new Promise((resolve, _) => {
    Bun.spawn(['bun', 'fix'], {
      onExit(proc, exitCode, signalCode, error) {
        if (error != null) {
          console.error(
            {stderr: proc.stderr, exitCode, signalCode},
            `Biome exited with error ${error.message}`,
          )
          resolve(exitCode ?? 1)
        } else {
          resolve(0)
        }
      },
    })
  })
  if (exitCode !== 0) throw new Error(`Biome failed with exit code ${exitCode}`)

  console.info('Done')
}
