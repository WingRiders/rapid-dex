import {type NetworkId, walletNetworkIdToNetwork} from '@/helpers/wallet'
import {poolValidatorCompiledCode, poolValidatorHash} from '@/onChain'
import {
  BlockfrostProvider,
  MeshTxBuilder,
  MeshWallet,
  type Network,
  applyCborEncoding,
  serializePlutusScript,
} from '@meshsdk/core'

const lovelaceOnRefScriptUtxo = 40_000_000

// Wrap to a CBOR array together with script version
const scriptCborToScriptRef = (scriptCbor: string) => `8203${scriptCbor}`

// The content doesn't need to be formatted, biome will be run on the file
// Provide full UTxO so it does not have to be fetched on every building of a transaction
const createResultFileContent = (
  network: Network,
  txHash: string,
  address: string,
  scriptCbor: string,
  scriptHash: string,
  scriptAddr: string,
  scriptSize: number,
): string =>
  [
    '// IMPORTANT: This file is automatically generated by createReferenceScriptUtxo script, do not edit it manually',
    "import type {UTxO} from '@meshsdk/core'",
    '',
    `export const ${network}PoolRefScriptUtxo: UTxO = {`,
    `  input: {txHash: '${txHash}', outputIndex: 0},`,
    `  output: {address: '${address}', amount: [{unit: 'lovelace', quantity: '${lovelaceOnRefScriptUtxo}'}], scriptRef: '${scriptCborToScriptRef(scriptCbor)}', scriptHash: '${scriptHash}'},`,
    '}',
    '',
    `export const ${network}PoolRefScriptSize = ${scriptSize}`,
    '',
    `export const ${network}PoolScriptAddress = '${scriptAddr}'`,
  ].join('\n')

type CreateReferenceScriptUtxoParams = {
  blockfrostProjectId: string
  networkId: NetworkId
  mnemonic: string
}

export const createReferenceScriptUtxo = async ({
  blockfrostProjectId,
  networkId,
  mnemonic,
}: CreateReferenceScriptUtxoParams) => {
  const blockchainProvider = new BlockfrostProvider(blockfrostProjectId)
  console.info('Init wallet')
  const wallet = new MeshWallet({
    networkId,
    fetcher: blockchainProvider,
    submitter: blockchainProvider,
    key: {
      type: 'mnemonic',
      words: mnemonic.split(' '),
    },
  })

  console.info('Fetching addresses')
  await wallet.init()
  const changeAddress = await wallet.getChangeAddress()

  console.info('Fetching UTxOs')
  const utxos = await wallet.getUtxos()
  if (utxos.length === 0) {
    console.error('Found no UTxOs, exiting')
    process.exit(1)
  }
  console.info(`Found ${utxos.length} UTxOs`)

  console.info(`Building transaction with output on ${changeAddress}`)
  const scriptCbor = applyCborEncoding(poolValidatorCompiledCode)
  const txBuilder = new MeshTxBuilder({
    fetcher: blockchainProvider,
    verbose: false,
  })
  const network = walletNetworkIdToNetwork(networkId)
  const unsignedTx = await txBuilder
    .setNetwork(network)
    .txOut(changeAddress, [
      {unit: 'lovelace', quantity: lovelaceOnRefScriptUtxo.toString()},
    ])
    .txOutReferenceScript(scriptCbor, 'V3')
    .changeAddress(changeAddress)
    .selectUtxosFrom(utxos)
    .complete()

  console.info({unsignedTx}, 'Signing transaction')
  const signedTx = await wallet.signTx(unsignedTx)
  console.info({signedTx}, 'Submitting transaction')
  const txHash = await wallet.submitTx(signedTx)
  console.info('Transaction submitted with hash:', txHash)

  const scriptAddr = serializePlutusScript({
    code: scriptCbor,
    version: 'V3',
  }).address
  console.info('Computed script address:', scriptAddr)

  const file = `src/refScriptUtxos/${network}.ts`
  console.info(`Writing reference script UTxO to file ${file}`)
  const content = createResultFileContent(
    network,
    txHash,
    changeAddress,
    scriptCbor,
    poolValidatorHash,
    scriptAddr,
    scriptCbor.length / 2,
  )
  await Bun.write(file, content)

  // Run Biome to format the file
  console.info(`Running Biome on ${file}`)
  const exitCode = await new Promise((resolve, _) => {
    Bun.spawn(['bun', 'fix'], {
      onExit(proc, exitCode, signalCode, error) {
        if (error != null) {
          console.error(
            {stderr: proc.stderr, exitCode, signalCode},
            `Biome exited with error ${error.message}`,
          )
          resolve(exitCode ?? 1)
        } else {
          resolve(0)
        }
      },
    })
  })
  if (exitCode !== 0) throw new Error(`Biome failed with exit code ${exitCode}`)

  console.info('Done')
}
